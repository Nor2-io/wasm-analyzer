// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod nornor {
    pub mod wasm_analyzer {
        #[allow(dead_code, clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[derive(Clone)]
            pub struct CustomSection {
                pub name: _rt::String,
                pub human_size: _rt::String,
                pub size: u64,
            }
            impl ::core::fmt::Debug for CustomSection {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CustomSection")
                        .field("name", &self.name)
                        .field("human-size", &self.human_size)
                        .field("size", &self.size)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Metadata {
                pub field: _rt::String,
                pub version: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for Metadata {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Metadata")
                        .field("field", &self.field)
                        .field("version", &self.version)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct UnkownField {
                pub field: _rt::String,
                pub metadata: Metadata,
            }
            impl ::core::fmt::Debug for UnkownField {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("UnkownField")
                        .field("field", &self.field)
                        .field("metadata", &self.metadata)
                        .finish()
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum WasmModuleType {
                Core,
                Component,
                Interface,
            }
            impl ::core::fmt::Debug for WasmModuleType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        WasmModuleType::Core => {
                            f.debug_tuple("WasmModuleType::Core").finish()
                        }
                        WasmModuleType::Component => {
                            f.debug_tuple("WasmModuleType::Component").finish()
                        }
                        WasmModuleType::Interface => {
                            f.debug_tuple("WasmModuleType::Interface").finish()
                        }
                    }
                }
            }
            impl WasmModuleType {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> WasmModuleType {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => WasmModuleType::Core,
                        1 => WasmModuleType::Component,
                        2 => WasmModuleType::Interface,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[derive(Clone)]
            pub struct MetadataInformation {
                pub name: _rt::String,
                pub size: u64,
                pub human_size: _rt::String,
                pub sha256: _rt::String,
                pub languages: _rt::Vec<Metadata>,
                pub tools: _rt::Vec<Metadata>,
                pub sdks: _rt::Vec<Metadata>,
                pub unknow_metadata: _rt::Vec<UnkownField>,
                pub num_custom_sections: u32,
                pub num_core_imports: u32,
                pub num_core_export: u32,
            }
            impl ::core::fmt::Debug for MetadataInformation {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("MetadataInformation")
                        .field("name", &self.name)
                        .field("size", &self.size)
                        .field("human-size", &self.human_size)
                        .field("sha256", &self.sha256)
                        .field("languages", &self.languages)
                        .field("tools", &self.tools)
                        .field("sdks", &self.sdks)
                        .field("unknow-metadata", &self.unknow_metadata)
                        .field("num-custom-sections", &self.num_custom_sections)
                        .field("num-core-imports", &self.num_core_imports)
                        .field("num-core-export", &self.num_core_export)
                        .finish()
                }
            }
            #[derive(Clone, Copy)]
            pub enum RefType {
                Any,
                None,
                NoExtern,
                NoFunc,
                Eq,
                Struct,
                Array,
                I31,
                Extern,
                Func,
                Exn,
                NoExn,
                Cont,
                NoCont,
                Indexed(u32),
            }
            impl ::core::fmt::Debug for RefType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        RefType::Any => f.debug_tuple("RefType::Any").finish(),
                        RefType::None => f.debug_tuple("RefType::None").finish(),
                        RefType::NoExtern => f.debug_tuple("RefType::NoExtern").finish(),
                        RefType::NoFunc => f.debug_tuple("RefType::NoFunc").finish(),
                        RefType::Eq => f.debug_tuple("RefType::Eq").finish(),
                        RefType::Struct => f.debug_tuple("RefType::Struct").finish(),
                        RefType::Array => f.debug_tuple("RefType::Array").finish(),
                        RefType::I31 => f.debug_tuple("RefType::I31").finish(),
                        RefType::Extern => f.debug_tuple("RefType::Extern").finish(),
                        RefType::Func => f.debug_tuple("RefType::Func").finish(),
                        RefType::Exn => f.debug_tuple("RefType::Exn").finish(),
                        RefType::NoExn => f.debug_tuple("RefType::NoExn").finish(),
                        RefType::Cont => f.debug_tuple("RefType::Cont").finish(),
                        RefType::NoCont => f.debug_tuple("RefType::NoCont").finish(),
                        RefType::Indexed(e) => {
                            f.debug_tuple("RefType::Indexed").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone, Copy)]
            pub enum WasmType {
                /// Signed 32 bit integer.
                I32,
                /// Signed 64 bit integer.
                I64,
                /// Floating point 32 bit integer.
                F32,
                /// Floating point 64 bit integer.
                F64,
                /// A 128 bit number.
                V128,
                /// A reference to opaque data in the Wasm instance.
                RefType(RefType),
            }
            impl ::core::fmt::Debug for WasmType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        WasmType::I32 => f.debug_tuple("WasmType::I32").finish(),
                        WasmType::I64 => f.debug_tuple("WasmType::I64").finish(),
                        WasmType::F32 => f.debug_tuple("WasmType::F32").finish(),
                        WasmType::F64 => f.debug_tuple("WasmType::F64").finish(),
                        WasmType::V128 => f.debug_tuple("WasmType::V128").finish(),
                        WasmType::RefType(e) => {
                            f.debug_tuple("WasmType::RefType").field(e).finish()
                        }
                    }
                }
            }
        }
        /// record component-information {
        /// custom-sections: list<custom-section>,
        /// name: string,
        /// size: u64,
        /// human-size: string,
        /// sha256: string,
        /// imports: imports,
        /// exports: exports,
        /// languages: list<metadata>,
        /// tools: list<metadata>,
        /// sdks: list<metadata>,
        /// unknow-metadata: list<unkown-field>,
        /// //registry-metadata: option<registry-metadata>,
        /// wat: option<string>,
        /// wit: option<string>,
        /// //children: list<ComponentInfo>,
        /// }
        ///
        /// record module-information {
        /// custom-sections: list<custom-section>,
        /// name: string,
        /// size: u64,
        /// human-size: string,
        /// sha256: string,
        /// imports: imports,
        /// exports: exports,
        /// languages: list<metadata>,
        /// tools: list<metadata>,
        /// sdks: list<metadata>,
        /// unknow-metadata: list<unkown-field>,
        /// //registry-metadata: option<registry-metadata>,
        /// wat: option<string>,
        /// wit: option<string>,
        /// }
        #[allow(dead_code, clippy::all)]
        pub mod core_import {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type WasmType = super::super::super::nornor::wasm_analyzer::types::WasmType;
            #[derive(Clone)]
            pub struct Function {
                pub module: _rt::String,
                pub field: _rt::String,
                pub index: u32,
                pub params: _rt::Vec<WasmType>,
                pub results: _rt::Vec<WasmType>,
            }
            impl ::core::fmt::Debug for Function {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Function")
                        .field("module", &self.module)
                        .field("field", &self.field)
                        .field("index", &self.index)
                        .field("params", &self.params)
                        .field("results", &self.results)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Table {
                pub module: _rt::String,
                pub field: _rt::String,
                pub index: u32,
                /// The type of data stored in elements of the table.
                pub ty: WasmType,
                /// The minimum number of elements in the table.
                pub minimum: u64,
                /// The maximum number of elements in the table.
                pub maximum: Option<u64>,
            }
            impl ::core::fmt::Debug for Table {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Table")
                        .field("module", &self.module)
                        .field("field", &self.field)
                        .field("index", &self.index)
                        .field("ty", &self.ty)
                        .field("minimum", &self.minimum)
                        .field("maximum", &self.maximum)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Memory {
                pub module: _rt::String,
                pub field: _rt::String,
                pub index: u32,
                pub minimum_pages: u64,
                pub maximum_pages: Option<u64>,
                pub human_minimum_size: _rt::String,
                pub human_maximum_size: Option<_rt::String>,
                pub shared: bool,
                pub memory64: bool,
            }
            impl ::core::fmt::Debug for Memory {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Memory")
                        .field("module", &self.module)
                        .field("field", &self.field)
                        .field("index", &self.index)
                        .field("minimum-pages", &self.minimum_pages)
                        .field("maximum-pages", &self.maximum_pages)
                        .field("human-minimum-size", &self.human_minimum_size)
                        .field("human-maximum-size", &self.human_maximum_size)
                        .field("shared", &self.shared)
                        .field("memory64", &self.memory64)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Global {
                pub module: _rt::String,
                pub field: _rt::String,
                pub index: u32,
                pub ty: WasmType,
                pub mutable: bool,
            }
            impl ::core::fmt::Debug for Global {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Global")
                        .field("module", &self.module)
                        .field("field", &self.field)
                        .field("index", &self.index)
                        .field("ty", &self.ty)
                        .field("mutable", &self.mutable)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct CoreImports {
                pub functions: _rt::Vec<Function>,
                pub tables: _rt::Vec<Table>,
                pub memories: _rt::Vec<Memory>,
                pub globals: _rt::Vec<Global>,
            }
            impl ::core::fmt::Debug for CoreImports {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CoreImports")
                        .field("functions", &self.functions)
                        .field("tables", &self.tables)
                        .field("memories", &self.memories)
                        .field("globals", &self.globals)
                        .finish()
                }
            }
        }
        #[allow(dead_code, clippy::all)]
        pub mod core_export {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type WasmType = super::super::super::nornor::wasm_analyzer::types::WasmType;
            #[derive(Clone)]
            pub struct Function {
                pub field: _rt::String,
                pub index: u32,
                pub params: _rt::Vec<WasmType>,
                pub results: _rt::Vec<WasmType>,
            }
            impl ::core::fmt::Debug for Function {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Function")
                        .field("field", &self.field)
                        .field("index", &self.index)
                        .field("params", &self.params)
                        .field("results", &self.results)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Table {
                pub field: _rt::String,
                pub index: u32,
                /// The type of data stored in elements of the table.
                pub ty: WasmType,
                /// The minimum number of elements in the table.
                pub minimum: u64,
                /// The maximum number of elements in the table.
                pub maximum: Option<u64>,
            }
            impl ::core::fmt::Debug for Table {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Table")
                        .field("field", &self.field)
                        .field("index", &self.index)
                        .field("ty", &self.ty)
                        .field("minimum", &self.minimum)
                        .field("maximum", &self.maximum)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Memory {
                pub field: _rt::String,
                pub index: u32,
                pub minimum_pages: u64,
                pub maximum_pages: Option<u64>,
                pub human_minimum_size: _rt::String,
                pub human_maximum_size: Option<_rt::String>,
                pub shared: bool,
                pub memory64: bool,
            }
            impl ::core::fmt::Debug for Memory {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Memory")
                        .field("field", &self.field)
                        .field("index", &self.index)
                        .field("minimum-pages", &self.minimum_pages)
                        .field("maximum-pages", &self.maximum_pages)
                        .field("human-minimum-size", &self.human_minimum_size)
                        .field("human-maximum-size", &self.human_maximum_size)
                        .field("shared", &self.shared)
                        .field("memory64", &self.memory64)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Global {
                pub field: _rt::String,
                pub index: u32,
                pub ty: WasmType,
                pub mutable: bool,
            }
            impl ::core::fmt::Debug for Global {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Global")
                        .field("field", &self.field)
                        .field("index", &self.index)
                        .field("ty", &self.ty)
                        .field("mutable", &self.mutable)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct CoreExports {
                pub functions: _rt::Vec<Function>,
                pub tables: _rt::Vec<Table>,
                pub memories: _rt::Vec<Memory>,
                pub globals: _rt::Vec<Global>,
            }
            impl ::core::fmt::Debug for CoreExports {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CoreExports")
                        .field("functions", &self.functions)
                        .field("tables", &self.tables)
                        .field("memories", &self.memories)
                        .field("globals", &self.globals)
                        .finish()
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod nornor {
        pub mod wasm_analyzer {
            #[allow(dead_code, clippy::all)]
            pub mod reader {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type CoreImports = super::super::super::super::nornor::wasm_analyzer::core_import::CoreImports;
                pub type CoreExports = super::super::super::super::nornor::wasm_analyzer::core_export::CoreExports;
                pub type WasmModuleType = super::super::super::super::nornor::wasm_analyzer::types::WasmModuleType;
                pub type MetadataInformation = super::super::super::super::nornor::wasm_analyzer::types::MetadataInformation;
                pub type CustomSection = super::super::super::super::nornor::wasm_analyzer::types::CustomSection;
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct Component {
                    handle: _rt::Resource<Component>,
                }
                type _ComponentRep<T> = Option<T>;
                impl Component {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `Component`.
                    pub fn new<T: GuestComponent>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _ComponentRep<T> = Some(val);
                        let ptr: *mut _ComponentRep<T> = _rt::Box::into_raw(
                            _rt::Box::new(val),
                        );
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }
                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestComponent>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestComponent>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }
                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestComponent>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: _rt::Resource::from_handle(handle),
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(! cfg!(target_feature = "atomics"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => {
                                    assert!(
                                        ty == id, "cannot use two types with this resource type"
                                    )
                                }
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }
                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = _rt::Box::from_raw(handle as *mut _ComponentRep<T>);
                    }
                    fn as_ptr<T: GuestComponent>(&self) -> *mut _ComponentRep<T> {
                        Component::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }
                /// A borrowed version of [`Component`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct ComponentBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a Component>,
                }
                impl<'a> ComponentBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }
                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestComponent>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    fn as_ptr<T: 'static>(&self) -> *mut _ComponentRep<T> {
                        Component::type_guard::<T>();
                        self.rep.cast()
                    }
                }
                unsafe impl _rt::WasmResource for Component {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nornor:wasm-analyzer/reader@0.1.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-drop]component"]
                                fn drop(_: u32);
                            }
                            drop(_handle);
                        }
                    }
                }
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct WasmReader {
                    handle: _rt::Resource<WasmReader>,
                }
                type _WasmReaderRep<T> = Option<T>;
                impl WasmReader {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `WasmReader`.
                    pub fn new<T: GuestWasmReader>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _WasmReaderRep<T> = Some(val);
                        let ptr: *mut _WasmReaderRep<T> = _rt::Box::into_raw(
                            _rt::Box::new(val),
                        );
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }
                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestWasmReader>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestWasmReader>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }
                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestWasmReader>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: _rt::Resource::from_handle(handle),
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(! cfg!(target_feature = "atomics"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => {
                                    assert!(
                                        ty == id, "cannot use two types with this resource type"
                                    )
                                }
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }
                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = _rt::Box::from_raw(handle as *mut _WasmReaderRep<T>);
                    }
                    fn as_ptr<T: GuestWasmReader>(&self) -> *mut _WasmReaderRep<T> {
                        WasmReader::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }
                /// A borrowed version of [`WasmReader`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct WasmReaderBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a WasmReader>,
                }
                impl<'a> WasmReaderBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }
                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestWasmReader>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    fn as_ptr<T: 'static>(&self) -> *mut _WasmReaderRep<T> {
                        WasmReader::type_guard::<T>();
                        self.rep.cast()
                    }
                }
                unsafe impl _rt::WasmResource for WasmReader {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nornor:wasm-analyzer/reader@0.1.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-drop]wasm-reader"]
                                fn drop(_: u32);
                            }
                            drop(_handle);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_constructor_component_cabi<T: GuestComponent>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = Component::new(
                        T::new(_rt::Vec::from_raw_parts(arg0.cast(), len0, len0)),
                    );
                    (result1).take_handle() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_component_get_type_cabi<T: GuestComponent>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_type(
                        ComponentBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    result0.clone() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_component_get_module_information_cabi<
                    T: GuestComponent,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_module_information(
                        ComponentBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let super::super::super::super::nornor::wasm_analyzer::types::MetadataInformation {
                        name: name2,
                        size: size2,
                        human_size: human_size2,
                        sha256: sha2562,
                        languages: languages2,
                        tools: tools2,
                        sdks: sdks2,
                        unknow_metadata: unknow_metadata2,
                        num_custom_sections: num_custom_sections2,
                        num_core_imports: num_core_imports2,
                        num_core_export: num_core_export2,
                    } = result0;
                    let vec3 = (name2.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr1.add(4).cast::<usize>() = len3;
                    *ptr1.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    *ptr1.add(8).cast::<i64>() = _rt::as_i64(size2);
                    let vec4 = (human_size2.into_bytes()).into_boxed_slice();
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    ::core::mem::forget(vec4);
                    *ptr1.add(20).cast::<usize>() = len4;
                    *ptr1.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                    let vec5 = (sha2562.into_bytes()).into_boxed_slice();
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    ::core::mem::forget(vec5);
                    *ptr1.add(28).cast::<usize>() = len5;
                    *ptr1.add(24).cast::<*mut u8>() = ptr5.cast_mut();
                    let vec9 = languages2;
                    let len9 = vec9.len();
                    let layout9 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec9.len() * 20,
                        4,
                    );
                    let result9 = if layout9.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout9).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout9);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec9.into_iter().enumerate() {
                        let base = result9.add(i * 20);
                        {
                            let super::super::super::super::nornor::wasm_analyzer::types::Metadata {
                                field: field6,
                                version: version6,
                            } = e;
                            let vec7 = (field6.into_bytes()).into_boxed_slice();
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            ::core::mem::forget(vec7);
                            *base.add(4).cast::<usize>() = len7;
                            *base.add(0).cast::<*mut u8>() = ptr7.cast_mut();
                            match version6 {
                                Some(e) => {
                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *base.add(16).cast::<usize>() = len8;
                                    *base.add(12).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                None => {
                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                    }
                    *ptr1.add(36).cast::<usize>() = len9;
                    *ptr1.add(32).cast::<*mut u8>() = result9;
                    let vec13 = tools2;
                    let len13 = vec13.len();
                    let layout13 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec13.len() * 20,
                        4,
                    );
                    let result13 = if layout13.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout13).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout13);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec13.into_iter().enumerate() {
                        let base = result13.add(i * 20);
                        {
                            let super::super::super::super::nornor::wasm_analyzer::types::Metadata {
                                field: field10,
                                version: version10,
                            } = e;
                            let vec11 = (field10.into_bytes()).into_boxed_slice();
                            let ptr11 = vec11.as_ptr().cast::<u8>();
                            let len11 = vec11.len();
                            ::core::mem::forget(vec11);
                            *base.add(4).cast::<usize>() = len11;
                            *base.add(0).cast::<*mut u8>() = ptr11.cast_mut();
                            match version10 {
                                Some(e) => {
                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *base.add(16).cast::<usize>() = len12;
                                    *base.add(12).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                None => {
                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                    }
                    *ptr1.add(44).cast::<usize>() = len13;
                    *ptr1.add(40).cast::<*mut u8>() = result13;
                    let vec17 = sdks2;
                    let len17 = vec17.len();
                    let layout17 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec17.len() * 20,
                        4,
                    );
                    let result17 = if layout17.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout17).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout17);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec17.into_iter().enumerate() {
                        let base = result17.add(i * 20);
                        {
                            let super::super::super::super::nornor::wasm_analyzer::types::Metadata {
                                field: field14,
                                version: version14,
                            } = e;
                            let vec15 = (field14.into_bytes()).into_boxed_slice();
                            let ptr15 = vec15.as_ptr().cast::<u8>();
                            let len15 = vec15.len();
                            ::core::mem::forget(vec15);
                            *base.add(4).cast::<usize>() = len15;
                            *base.add(0).cast::<*mut u8>() = ptr15.cast_mut();
                            match version14 {
                                Some(e) => {
                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *base.add(16).cast::<usize>() = len16;
                                    *base.add(12).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                None => {
                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                    }
                    *ptr1.add(52).cast::<usize>() = len17;
                    *ptr1.add(48).cast::<*mut u8>() = result17;
                    let vec23 = unknow_metadata2;
                    let len23 = vec23.len();
                    let layout23 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec23.len() * 28,
                        4,
                    );
                    let result23 = if layout23.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout23).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout23);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec23.into_iter().enumerate() {
                        let base = result23.add(i * 28);
                        {
                            let super::super::super::super::nornor::wasm_analyzer::types::UnkownField {
                                field: field18,
                                metadata: metadata18,
                            } = e;
                            let vec19 = (field18.into_bytes()).into_boxed_slice();
                            let ptr19 = vec19.as_ptr().cast::<u8>();
                            let len19 = vec19.len();
                            ::core::mem::forget(vec19);
                            *base.add(4).cast::<usize>() = len19;
                            *base.add(0).cast::<*mut u8>() = ptr19.cast_mut();
                            let super::super::super::super::nornor::wasm_analyzer::types::Metadata {
                                field: field20,
                                version: version20,
                            } = metadata18;
                            let vec21 = (field20.into_bytes()).into_boxed_slice();
                            let ptr21 = vec21.as_ptr().cast::<u8>();
                            let len21 = vec21.len();
                            ::core::mem::forget(vec21);
                            *base.add(12).cast::<usize>() = len21;
                            *base.add(8).cast::<*mut u8>() = ptr21.cast_mut();
                            match version20 {
                                Some(e) => {
                                    *base.add(16).cast::<u8>() = (1i32) as u8;
                                    let vec22 = (e.into_bytes()).into_boxed_slice();
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();
                                    ::core::mem::forget(vec22);
                                    *base.add(24).cast::<usize>() = len22;
                                    *base.add(20).cast::<*mut u8>() = ptr22.cast_mut();
                                }
                                None => {
                                    *base.add(16).cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                    }
                    *ptr1.add(60).cast::<usize>() = len23;
                    *ptr1.add(56).cast::<*mut u8>() = result23;
                    *ptr1.add(64).cast::<i32>() = _rt::as_i32(num_custom_sections2);
                    *ptr1.add(68).cast::<i32>() = _rt::as_i32(num_core_imports2);
                    *ptr1.add(72).cast::<i32>() = _rt::as_i32(num_core_export2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_component_get_module_information<
                    T: GuestComponent,
                >(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                    let l2 = *arg0.add(16).cast::<*mut u8>();
                    let l3 = *arg0.add(20).cast::<usize>();
                    _rt::cabi_dealloc(l2, l3, 1);
                    let l4 = *arg0.add(24).cast::<*mut u8>();
                    let l5 = *arg0.add(28).cast::<usize>();
                    _rt::cabi_dealloc(l4, l5, 1);
                    let l6 = *arg0.add(32).cast::<*mut u8>();
                    let l7 = *arg0.add(36).cast::<usize>();
                    let base13 = l6;
                    let len13 = l7;
                    for i in 0..len13 {
                        let base = base13.add(i * 20);
                        {
                            let l8 = *base.add(0).cast::<*mut u8>();
                            let l9 = *base.add(4).cast::<usize>();
                            _rt::cabi_dealloc(l8, l9, 1);
                            let l10 = i32::from(*base.add(8).cast::<u8>());
                            match l10 {
                                0 => {}
                                _ => {
                                    let l11 = *base.add(12).cast::<*mut u8>();
                                    let l12 = *base.add(16).cast::<usize>();
                                    _rt::cabi_dealloc(l11, l12, 1);
                                }
                            }
                        }
                    }
                    _rt::cabi_dealloc(base13, len13 * 20, 4);
                    let l14 = *arg0.add(40).cast::<*mut u8>();
                    let l15 = *arg0.add(44).cast::<usize>();
                    let base21 = l14;
                    let len21 = l15;
                    for i in 0..len21 {
                        let base = base21.add(i * 20);
                        {
                            let l16 = *base.add(0).cast::<*mut u8>();
                            let l17 = *base.add(4).cast::<usize>();
                            _rt::cabi_dealloc(l16, l17, 1);
                            let l18 = i32::from(*base.add(8).cast::<u8>());
                            match l18 {
                                0 => {}
                                _ => {
                                    let l19 = *base.add(12).cast::<*mut u8>();
                                    let l20 = *base.add(16).cast::<usize>();
                                    _rt::cabi_dealloc(l19, l20, 1);
                                }
                            }
                        }
                    }
                    _rt::cabi_dealloc(base21, len21 * 20, 4);
                    let l22 = *arg0.add(48).cast::<*mut u8>();
                    let l23 = *arg0.add(52).cast::<usize>();
                    let base29 = l22;
                    let len29 = l23;
                    for i in 0..len29 {
                        let base = base29.add(i * 20);
                        {
                            let l24 = *base.add(0).cast::<*mut u8>();
                            let l25 = *base.add(4).cast::<usize>();
                            _rt::cabi_dealloc(l24, l25, 1);
                            let l26 = i32::from(*base.add(8).cast::<u8>());
                            match l26 {
                                0 => {}
                                _ => {
                                    let l27 = *base.add(12).cast::<*mut u8>();
                                    let l28 = *base.add(16).cast::<usize>();
                                    _rt::cabi_dealloc(l27, l28, 1);
                                }
                            }
                        }
                    }
                    _rt::cabi_dealloc(base29, len29 * 20, 4);
                    let l30 = *arg0.add(56).cast::<*mut u8>();
                    let l31 = *arg0.add(60).cast::<usize>();
                    let base39 = l30;
                    let len39 = l31;
                    for i in 0..len39 {
                        let base = base39.add(i * 28);
                        {
                            let l32 = *base.add(0).cast::<*mut u8>();
                            let l33 = *base.add(4).cast::<usize>();
                            _rt::cabi_dealloc(l32, l33, 1);
                            let l34 = *base.add(8).cast::<*mut u8>();
                            let l35 = *base.add(12).cast::<usize>();
                            _rt::cabi_dealloc(l34, l35, 1);
                            let l36 = i32::from(*base.add(16).cast::<u8>());
                            match l36 {
                                0 => {}
                                _ => {
                                    let l37 = *base.add(20).cast::<*mut u8>();
                                    let l38 = *base.add(24).cast::<usize>();
                                    _rt::cabi_dealloc(l37, l38, 1);
                                }
                            }
                        }
                    }
                    _rt::cabi_dealloc(base39, len39 * 28, 4);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_component_get_core_imports_cabi<
                    T: GuestComponent,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_core_imports(
                        ComponentBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let super::super::super::super::nornor::wasm_analyzer::core_import::CoreImports {
                        functions: functions2,
                        tables: tables2,
                        memories: memories2,
                        globals: globals2,
                    } = result0;
                    let vec12 = functions2;
                    let len12 = vec12.len();
                    let layout12 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec12.len() * 36,
                        4,
                    );
                    let result12 = if layout12.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout12);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec12.into_iter().enumerate() {
                        let base = result12.add(i * 36);
                        {
                            let super::super::super::super::nornor::wasm_analyzer::core_import::Function {
                                module: module3,
                                field: field3,
                                index: index3,
                                params: params3,
                                results: results3,
                            } = e;
                            let vec4 = (module3.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *base.add(4).cast::<usize>() = len4;
                            *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                            let vec5 = (field3.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *base.add(12).cast::<usize>() = len5;
                            *base.add(8).cast::<*mut u8>() = ptr5.cast_mut();
                            *base.add(16).cast::<i32>() = _rt::as_i32(index3);
                            let vec8 = params3;
                            let len8 = vec8.len();
                            let layout8 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec8.len() * 12,
                                4,
                            );
                            let result8 = if layout8.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout8);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec8.into_iter().enumerate() {
                                let base = result8.add(i * 12);
                                {
                                    use super::super::super::super::nornor::wasm_analyzer::types::WasmType as V7;
                                    match e {
                                        V7::I32 => {
                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                        }
                                        V7::I64 => {
                                            *base.add(0).cast::<u8>() = (1i32) as u8;
                                        }
                                        V7::F32 => {
                                            *base.add(0).cast::<u8>() = (2i32) as u8;
                                        }
                                        V7::F64 => {
                                            *base.add(0).cast::<u8>() = (3i32) as u8;
                                        }
                                        V7::V128 => {
                                            *base.add(0).cast::<u8>() = (4i32) as u8;
                                        }
                                        V7::RefType(e) => {
                                            *base.add(0).cast::<u8>() = (5i32) as u8;
                                            use super::super::super::super::nornor::wasm_analyzer::types::RefType as V6;
                                            match e {
                                                V6::Any => {
                                                    *base.add(4).cast::<u8>() = (0i32) as u8;
                                                }
                                                V6::None => {
                                                    *base.add(4).cast::<u8>() = (1i32) as u8;
                                                }
                                                V6::NoExtern => {
                                                    *base.add(4).cast::<u8>() = (2i32) as u8;
                                                }
                                                V6::NoFunc => {
                                                    *base.add(4).cast::<u8>() = (3i32) as u8;
                                                }
                                                V6::Eq => {
                                                    *base.add(4).cast::<u8>() = (4i32) as u8;
                                                }
                                                V6::Struct => {
                                                    *base.add(4).cast::<u8>() = (5i32) as u8;
                                                }
                                                V6::Array => {
                                                    *base.add(4).cast::<u8>() = (6i32) as u8;
                                                }
                                                V6::I31 => {
                                                    *base.add(4).cast::<u8>() = (7i32) as u8;
                                                }
                                                V6::Extern => {
                                                    *base.add(4).cast::<u8>() = (8i32) as u8;
                                                }
                                                V6::Func => {
                                                    *base.add(4).cast::<u8>() = (9i32) as u8;
                                                }
                                                V6::Exn => {
                                                    *base.add(4).cast::<u8>() = (10i32) as u8;
                                                }
                                                V6::NoExn => {
                                                    *base.add(4).cast::<u8>() = (11i32) as u8;
                                                }
                                                V6::Cont => {
                                                    *base.add(4).cast::<u8>() = (12i32) as u8;
                                                }
                                                V6::NoCont => {
                                                    *base.add(4).cast::<u8>() = (13i32) as u8;
                                                }
                                                V6::Indexed(e) => {
                                                    *base.add(4).cast::<u8>() = (14i32) as u8;
                                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            *base.add(24).cast::<usize>() = len8;
                            *base.add(20).cast::<*mut u8>() = result8;
                            let vec11 = results3;
                            let len11 = vec11.len();
                            let layout11 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec11.len() * 12,
                                4,
                            );
                            let result11 = if layout11.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout11).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout11);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec11.into_iter().enumerate() {
                                let base = result11.add(i * 12);
                                {
                                    use super::super::super::super::nornor::wasm_analyzer::types::WasmType as V10;
                                    match e {
                                        V10::I32 => {
                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                        }
                                        V10::I64 => {
                                            *base.add(0).cast::<u8>() = (1i32) as u8;
                                        }
                                        V10::F32 => {
                                            *base.add(0).cast::<u8>() = (2i32) as u8;
                                        }
                                        V10::F64 => {
                                            *base.add(0).cast::<u8>() = (3i32) as u8;
                                        }
                                        V10::V128 => {
                                            *base.add(0).cast::<u8>() = (4i32) as u8;
                                        }
                                        V10::RefType(e) => {
                                            *base.add(0).cast::<u8>() = (5i32) as u8;
                                            use super::super::super::super::nornor::wasm_analyzer::types::RefType as V9;
                                            match e {
                                                V9::Any => {
                                                    *base.add(4).cast::<u8>() = (0i32) as u8;
                                                }
                                                V9::None => {
                                                    *base.add(4).cast::<u8>() = (1i32) as u8;
                                                }
                                                V9::NoExtern => {
                                                    *base.add(4).cast::<u8>() = (2i32) as u8;
                                                }
                                                V9::NoFunc => {
                                                    *base.add(4).cast::<u8>() = (3i32) as u8;
                                                }
                                                V9::Eq => {
                                                    *base.add(4).cast::<u8>() = (4i32) as u8;
                                                }
                                                V9::Struct => {
                                                    *base.add(4).cast::<u8>() = (5i32) as u8;
                                                }
                                                V9::Array => {
                                                    *base.add(4).cast::<u8>() = (6i32) as u8;
                                                }
                                                V9::I31 => {
                                                    *base.add(4).cast::<u8>() = (7i32) as u8;
                                                }
                                                V9::Extern => {
                                                    *base.add(4).cast::<u8>() = (8i32) as u8;
                                                }
                                                V9::Func => {
                                                    *base.add(4).cast::<u8>() = (9i32) as u8;
                                                }
                                                V9::Exn => {
                                                    *base.add(4).cast::<u8>() = (10i32) as u8;
                                                }
                                                V9::NoExn => {
                                                    *base.add(4).cast::<u8>() = (11i32) as u8;
                                                }
                                                V9::Cont => {
                                                    *base.add(4).cast::<u8>() = (12i32) as u8;
                                                }
                                                V9::NoCont => {
                                                    *base.add(4).cast::<u8>() = (13i32) as u8;
                                                }
                                                V9::Indexed(e) => {
                                                    *base.add(4).cast::<u8>() = (14i32) as u8;
                                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            *base.add(32).cast::<usize>() = len11;
                            *base.add(28).cast::<*mut u8>() = result11;
                        }
                    }
                    *ptr1.add(4).cast::<usize>() = len12;
                    *ptr1.add(0).cast::<*mut u8>() = result12;
                    let vec18 = tables2;
                    let len18 = vec18.len();
                    let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec18.len() * 56,
                        8,
                    );
                    let result18 = if layout18.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout18);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec18.into_iter().enumerate() {
                        let base = result18.add(i * 56);
                        {
                            let super::super::super::super::nornor::wasm_analyzer::core_import::Table {
                                module: module13,
                                field: field13,
                                index: index13,
                                ty: ty13,
                                minimum: minimum13,
                                maximum: maximum13,
                            } = e;
                            let vec14 = (module13.into_bytes()).into_boxed_slice();
                            let ptr14 = vec14.as_ptr().cast::<u8>();
                            let len14 = vec14.len();
                            ::core::mem::forget(vec14);
                            *base.add(4).cast::<usize>() = len14;
                            *base.add(0).cast::<*mut u8>() = ptr14.cast_mut();
                            let vec15 = (field13.into_bytes()).into_boxed_slice();
                            let ptr15 = vec15.as_ptr().cast::<u8>();
                            let len15 = vec15.len();
                            ::core::mem::forget(vec15);
                            *base.add(12).cast::<usize>() = len15;
                            *base.add(8).cast::<*mut u8>() = ptr15.cast_mut();
                            *base.add(16).cast::<i32>() = _rt::as_i32(index13);
                            use super::super::super::super::nornor::wasm_analyzer::types::WasmType as V17;
                            match ty13 {
                                V17::I32 => {
                                    *base.add(20).cast::<u8>() = (0i32) as u8;
                                }
                                V17::I64 => {
                                    *base.add(20).cast::<u8>() = (1i32) as u8;
                                }
                                V17::F32 => {
                                    *base.add(20).cast::<u8>() = (2i32) as u8;
                                }
                                V17::F64 => {
                                    *base.add(20).cast::<u8>() = (3i32) as u8;
                                }
                                V17::V128 => {
                                    *base.add(20).cast::<u8>() = (4i32) as u8;
                                }
                                V17::RefType(e) => {
                                    *base.add(20).cast::<u8>() = (5i32) as u8;
                                    use super::super::super::super::nornor::wasm_analyzer::types::RefType as V16;
                                    match e {
                                        V16::Any => {
                                            *base.add(24).cast::<u8>() = (0i32) as u8;
                                        }
                                        V16::None => {
                                            *base.add(24).cast::<u8>() = (1i32) as u8;
                                        }
                                        V16::NoExtern => {
                                            *base.add(24).cast::<u8>() = (2i32) as u8;
                                        }
                                        V16::NoFunc => {
                                            *base.add(24).cast::<u8>() = (3i32) as u8;
                                        }
                                        V16::Eq => {
                                            *base.add(24).cast::<u8>() = (4i32) as u8;
                                        }
                                        V16::Struct => {
                                            *base.add(24).cast::<u8>() = (5i32) as u8;
                                        }
                                        V16::Array => {
                                            *base.add(24).cast::<u8>() = (6i32) as u8;
                                        }
                                        V16::I31 => {
                                            *base.add(24).cast::<u8>() = (7i32) as u8;
                                        }
                                        V16::Extern => {
                                            *base.add(24).cast::<u8>() = (8i32) as u8;
                                        }
                                        V16::Func => {
                                            *base.add(24).cast::<u8>() = (9i32) as u8;
                                        }
                                        V16::Exn => {
                                            *base.add(24).cast::<u8>() = (10i32) as u8;
                                        }
                                        V16::NoExn => {
                                            *base.add(24).cast::<u8>() = (11i32) as u8;
                                        }
                                        V16::Cont => {
                                            *base.add(24).cast::<u8>() = (12i32) as u8;
                                        }
                                        V16::NoCont => {
                                            *base.add(24).cast::<u8>() = (13i32) as u8;
                                        }
                                        V16::Indexed(e) => {
                                            *base.add(24).cast::<u8>() = (14i32) as u8;
                                            *base.add(28).cast::<i32>() = _rt::as_i32(e);
                                        }
                                    }
                                }
                            }
                            *base.add(32).cast::<i64>() = _rt::as_i64(minimum13);
                            match maximum13 {
                                Some(e) => {
                                    *base.add(40).cast::<u8>() = (1i32) as u8;
                                    *base.add(48).cast::<i64>() = _rt::as_i64(e);
                                }
                                None => {
                                    *base.add(40).cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                    }
                    *ptr1.add(12).cast::<usize>() = len18;
                    *ptr1.add(8).cast::<*mut u8>() = result18;
                    let vec24 = memories2;
                    let len24 = vec24.len();
                    let layout24 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec24.len() * 72,
                        8,
                    );
                    let result24 = if layout24.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout24).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout24);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec24.into_iter().enumerate() {
                        let base = result24.add(i * 72);
                        {
                            let super::super::super::super::nornor::wasm_analyzer::core_import::Memory {
                                module: module19,
                                field: field19,
                                index: index19,
                                minimum_pages: minimum_pages19,
                                maximum_pages: maximum_pages19,
                                human_minimum_size: human_minimum_size19,
                                human_maximum_size: human_maximum_size19,
                                shared: shared19,
                                memory64: memory6419,
                            } = e;
                            let vec20 = (module19.into_bytes()).into_boxed_slice();
                            let ptr20 = vec20.as_ptr().cast::<u8>();
                            let len20 = vec20.len();
                            ::core::mem::forget(vec20);
                            *base.add(4).cast::<usize>() = len20;
                            *base.add(0).cast::<*mut u8>() = ptr20.cast_mut();
                            let vec21 = (field19.into_bytes()).into_boxed_slice();
                            let ptr21 = vec21.as_ptr().cast::<u8>();
                            let len21 = vec21.len();
                            ::core::mem::forget(vec21);
                            *base.add(12).cast::<usize>() = len21;
                            *base.add(8).cast::<*mut u8>() = ptr21.cast_mut();
                            *base.add(16).cast::<i32>() = _rt::as_i32(index19);
                            *base.add(24).cast::<i64>() = _rt::as_i64(minimum_pages19);
                            match maximum_pages19 {
                                Some(e) => {
                                    *base.add(32).cast::<u8>() = (1i32) as u8;
                                    *base.add(40).cast::<i64>() = _rt::as_i64(e);
                                }
                                None => {
                                    *base.add(32).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec22 = (human_minimum_size19.into_bytes())
                                .into_boxed_slice();
                            let ptr22 = vec22.as_ptr().cast::<u8>();
                            let len22 = vec22.len();
                            ::core::mem::forget(vec22);
                            *base.add(52).cast::<usize>() = len22;
                            *base.add(48).cast::<*mut u8>() = ptr22.cast_mut();
                            match human_maximum_size19 {
                                Some(e) => {
                                    *base.add(56).cast::<u8>() = (1i32) as u8;
                                    let vec23 = (e.into_bytes()).into_boxed_slice();
                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                    let len23 = vec23.len();
                                    ::core::mem::forget(vec23);
                                    *base.add(64).cast::<usize>() = len23;
                                    *base.add(60).cast::<*mut u8>() = ptr23.cast_mut();
                                }
                                None => {
                                    *base.add(56).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            *base.add(68).cast::<u8>() = (match shared19 {
                                true => 1,
                                false => 0,
                            }) as u8;
                            *base.add(69).cast::<u8>() = (match memory6419 {
                                true => 1,
                                false => 0,
                            }) as u8;
                        }
                    }
                    *ptr1.add(20).cast::<usize>() = len24;
                    *ptr1.add(16).cast::<*mut u8>() = result24;
                    let vec30 = globals2;
                    let len30 = vec30.len();
                    let layout30 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec30.len() * 36,
                        4,
                    );
                    let result30 = if layout30.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout30).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout30);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec30.into_iter().enumerate() {
                        let base = result30.add(i * 36);
                        {
                            let super::super::super::super::nornor::wasm_analyzer::core_import::Global {
                                module: module25,
                                field: field25,
                                index: index25,
                                ty: ty25,
                                mutable: mutable25,
                            } = e;
                            let vec26 = (module25.into_bytes()).into_boxed_slice();
                            let ptr26 = vec26.as_ptr().cast::<u8>();
                            let len26 = vec26.len();
                            ::core::mem::forget(vec26);
                            *base.add(4).cast::<usize>() = len26;
                            *base.add(0).cast::<*mut u8>() = ptr26.cast_mut();
                            let vec27 = (field25.into_bytes()).into_boxed_slice();
                            let ptr27 = vec27.as_ptr().cast::<u8>();
                            let len27 = vec27.len();
                            ::core::mem::forget(vec27);
                            *base.add(12).cast::<usize>() = len27;
                            *base.add(8).cast::<*mut u8>() = ptr27.cast_mut();
                            *base.add(16).cast::<i32>() = _rt::as_i32(index25);
                            use super::super::super::super::nornor::wasm_analyzer::types::WasmType as V29;
                            match ty25 {
                                V29::I32 => {
                                    *base.add(20).cast::<u8>() = (0i32) as u8;
                                }
                                V29::I64 => {
                                    *base.add(20).cast::<u8>() = (1i32) as u8;
                                }
                                V29::F32 => {
                                    *base.add(20).cast::<u8>() = (2i32) as u8;
                                }
                                V29::F64 => {
                                    *base.add(20).cast::<u8>() = (3i32) as u8;
                                }
                                V29::V128 => {
                                    *base.add(20).cast::<u8>() = (4i32) as u8;
                                }
                                V29::RefType(e) => {
                                    *base.add(20).cast::<u8>() = (5i32) as u8;
                                    use super::super::super::super::nornor::wasm_analyzer::types::RefType as V28;
                                    match e {
                                        V28::Any => {
                                            *base.add(24).cast::<u8>() = (0i32) as u8;
                                        }
                                        V28::None => {
                                            *base.add(24).cast::<u8>() = (1i32) as u8;
                                        }
                                        V28::NoExtern => {
                                            *base.add(24).cast::<u8>() = (2i32) as u8;
                                        }
                                        V28::NoFunc => {
                                            *base.add(24).cast::<u8>() = (3i32) as u8;
                                        }
                                        V28::Eq => {
                                            *base.add(24).cast::<u8>() = (4i32) as u8;
                                        }
                                        V28::Struct => {
                                            *base.add(24).cast::<u8>() = (5i32) as u8;
                                        }
                                        V28::Array => {
                                            *base.add(24).cast::<u8>() = (6i32) as u8;
                                        }
                                        V28::I31 => {
                                            *base.add(24).cast::<u8>() = (7i32) as u8;
                                        }
                                        V28::Extern => {
                                            *base.add(24).cast::<u8>() = (8i32) as u8;
                                        }
                                        V28::Func => {
                                            *base.add(24).cast::<u8>() = (9i32) as u8;
                                        }
                                        V28::Exn => {
                                            *base.add(24).cast::<u8>() = (10i32) as u8;
                                        }
                                        V28::NoExn => {
                                            *base.add(24).cast::<u8>() = (11i32) as u8;
                                        }
                                        V28::Cont => {
                                            *base.add(24).cast::<u8>() = (12i32) as u8;
                                        }
                                        V28::NoCont => {
                                            *base.add(24).cast::<u8>() = (13i32) as u8;
                                        }
                                        V28::Indexed(e) => {
                                            *base.add(24).cast::<u8>() = (14i32) as u8;
                                            *base.add(28).cast::<i32>() = _rt::as_i32(e);
                                        }
                                    }
                                }
                            }
                            *base.add(32).cast::<u8>() = (match mutable25 {
                                true => 1,
                                false => 0,
                            }) as u8;
                        }
                    }
                    *ptr1.add(28).cast::<usize>() = len30;
                    *ptr1.add(24).cast::<*mut u8>() = result30;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_component_get_core_imports<
                    T: GuestComponent,
                >(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let base12 = l0;
                    let len12 = l1;
                    for i in 0..len12 {
                        let base = base12.add(i * 36);
                        {
                            let l2 = *base.add(0).cast::<*mut u8>();
                            let l3 = *base.add(4).cast::<usize>();
                            _rt::cabi_dealloc(l2, l3, 1);
                            let l4 = *base.add(8).cast::<*mut u8>();
                            let l5 = *base.add(12).cast::<usize>();
                            _rt::cabi_dealloc(l4, l5, 1);
                            let l6 = *base.add(20).cast::<*mut u8>();
                            let l7 = *base.add(24).cast::<usize>();
                            let base8 = l6;
                            let len8 = l7;
                            _rt::cabi_dealloc(base8, len8 * 12, 4);
                            let l9 = *base.add(28).cast::<*mut u8>();
                            let l10 = *base.add(32).cast::<usize>();
                            let base11 = l9;
                            let len11 = l10;
                            _rt::cabi_dealloc(base11, len11 * 12, 4);
                        }
                    }
                    _rt::cabi_dealloc(base12, len12 * 36, 4);
                    let l13 = *arg0.add(8).cast::<*mut u8>();
                    let l14 = *arg0.add(12).cast::<usize>();
                    let base19 = l13;
                    let len19 = l14;
                    for i in 0..len19 {
                        let base = base19.add(i * 56);
                        {
                            let l15 = *base.add(0).cast::<*mut u8>();
                            let l16 = *base.add(4).cast::<usize>();
                            _rt::cabi_dealloc(l15, l16, 1);
                            let l17 = *base.add(8).cast::<*mut u8>();
                            let l18 = *base.add(12).cast::<usize>();
                            _rt::cabi_dealloc(l17, l18, 1);
                        }
                    }
                    _rt::cabi_dealloc(base19, len19 * 56, 8);
                    let l20 = *arg0.add(16).cast::<*mut u8>();
                    let l21 = *arg0.add(20).cast::<usize>();
                    let base31 = l20;
                    let len31 = l21;
                    for i in 0..len31 {
                        let base = base31.add(i * 72);
                        {
                            let l22 = *base.add(0).cast::<*mut u8>();
                            let l23 = *base.add(4).cast::<usize>();
                            _rt::cabi_dealloc(l22, l23, 1);
                            let l24 = *base.add(8).cast::<*mut u8>();
                            let l25 = *base.add(12).cast::<usize>();
                            _rt::cabi_dealloc(l24, l25, 1);
                            let l26 = *base.add(48).cast::<*mut u8>();
                            let l27 = *base.add(52).cast::<usize>();
                            _rt::cabi_dealloc(l26, l27, 1);
                            let l28 = i32::from(*base.add(56).cast::<u8>());
                            match l28 {
                                0 => {}
                                _ => {
                                    let l29 = *base.add(60).cast::<*mut u8>();
                                    let l30 = *base.add(64).cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                            }
                        }
                    }
                    _rt::cabi_dealloc(base31, len31 * 72, 8);
                    let l32 = *arg0.add(24).cast::<*mut u8>();
                    let l33 = *arg0.add(28).cast::<usize>();
                    let base38 = l32;
                    let len38 = l33;
                    for i in 0..len38 {
                        let base = base38.add(i * 36);
                        {
                            let l34 = *base.add(0).cast::<*mut u8>();
                            let l35 = *base.add(4).cast::<usize>();
                            _rt::cabi_dealloc(l34, l35, 1);
                            let l36 = *base.add(8).cast::<*mut u8>();
                            let l37 = *base.add(12).cast::<usize>();
                            _rt::cabi_dealloc(l36, l37, 1);
                        }
                    }
                    _rt::cabi_dealloc(base38, len38 * 36, 4);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_component_get_core_exports_cabi<
                    T: GuestComponent,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_core_exports(
                        ComponentBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let super::super::super::super::nornor::wasm_analyzer::core_export::CoreExports {
                        functions: functions2,
                        tables: tables2,
                        memories: memories2,
                        globals: globals2,
                    } = result0;
                    let vec11 = functions2;
                    let len11 = vec11.len();
                    let layout11 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec11.len() * 28,
                        4,
                    );
                    let result11 = if layout11.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout11).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout11);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec11.into_iter().enumerate() {
                        let base = result11.add(i * 28);
                        {
                            let super::super::super::super::nornor::wasm_analyzer::core_export::Function {
                                field: field3,
                                index: index3,
                                params: params3,
                                results: results3,
                            } = e;
                            let vec4 = (field3.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *base.add(4).cast::<usize>() = len4;
                            *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                            *base.add(8).cast::<i32>() = _rt::as_i32(index3);
                            let vec7 = params3;
                            let len7 = vec7.len();
                            let layout7 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec7.len() * 12,
                                4,
                            );
                            let result7 = if layout7.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout7);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec7.into_iter().enumerate() {
                                let base = result7.add(i * 12);
                                {
                                    use super::super::super::super::nornor::wasm_analyzer::types::WasmType as V6;
                                    match e {
                                        V6::I32 => {
                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                        }
                                        V6::I64 => {
                                            *base.add(0).cast::<u8>() = (1i32) as u8;
                                        }
                                        V6::F32 => {
                                            *base.add(0).cast::<u8>() = (2i32) as u8;
                                        }
                                        V6::F64 => {
                                            *base.add(0).cast::<u8>() = (3i32) as u8;
                                        }
                                        V6::V128 => {
                                            *base.add(0).cast::<u8>() = (4i32) as u8;
                                        }
                                        V6::RefType(e) => {
                                            *base.add(0).cast::<u8>() = (5i32) as u8;
                                            use super::super::super::super::nornor::wasm_analyzer::types::RefType as V5;
                                            match e {
                                                V5::Any => {
                                                    *base.add(4).cast::<u8>() = (0i32) as u8;
                                                }
                                                V5::None => {
                                                    *base.add(4).cast::<u8>() = (1i32) as u8;
                                                }
                                                V5::NoExtern => {
                                                    *base.add(4).cast::<u8>() = (2i32) as u8;
                                                }
                                                V5::NoFunc => {
                                                    *base.add(4).cast::<u8>() = (3i32) as u8;
                                                }
                                                V5::Eq => {
                                                    *base.add(4).cast::<u8>() = (4i32) as u8;
                                                }
                                                V5::Struct => {
                                                    *base.add(4).cast::<u8>() = (5i32) as u8;
                                                }
                                                V5::Array => {
                                                    *base.add(4).cast::<u8>() = (6i32) as u8;
                                                }
                                                V5::I31 => {
                                                    *base.add(4).cast::<u8>() = (7i32) as u8;
                                                }
                                                V5::Extern => {
                                                    *base.add(4).cast::<u8>() = (8i32) as u8;
                                                }
                                                V5::Func => {
                                                    *base.add(4).cast::<u8>() = (9i32) as u8;
                                                }
                                                V5::Exn => {
                                                    *base.add(4).cast::<u8>() = (10i32) as u8;
                                                }
                                                V5::NoExn => {
                                                    *base.add(4).cast::<u8>() = (11i32) as u8;
                                                }
                                                V5::Cont => {
                                                    *base.add(4).cast::<u8>() = (12i32) as u8;
                                                }
                                                V5::NoCont => {
                                                    *base.add(4).cast::<u8>() = (13i32) as u8;
                                                }
                                                V5::Indexed(e) => {
                                                    *base.add(4).cast::<u8>() = (14i32) as u8;
                                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            *base.add(16).cast::<usize>() = len7;
                            *base.add(12).cast::<*mut u8>() = result7;
                            let vec10 = results3;
                            let len10 = vec10.len();
                            let layout10 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec10.len() * 12,
                                4,
                            );
                            let result10 = if layout10.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout10).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout10);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec10.into_iter().enumerate() {
                                let base = result10.add(i * 12);
                                {
                                    use super::super::super::super::nornor::wasm_analyzer::types::WasmType as V9;
                                    match e {
                                        V9::I32 => {
                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                        }
                                        V9::I64 => {
                                            *base.add(0).cast::<u8>() = (1i32) as u8;
                                        }
                                        V9::F32 => {
                                            *base.add(0).cast::<u8>() = (2i32) as u8;
                                        }
                                        V9::F64 => {
                                            *base.add(0).cast::<u8>() = (3i32) as u8;
                                        }
                                        V9::V128 => {
                                            *base.add(0).cast::<u8>() = (4i32) as u8;
                                        }
                                        V9::RefType(e) => {
                                            *base.add(0).cast::<u8>() = (5i32) as u8;
                                            use super::super::super::super::nornor::wasm_analyzer::types::RefType as V8;
                                            match e {
                                                V8::Any => {
                                                    *base.add(4).cast::<u8>() = (0i32) as u8;
                                                }
                                                V8::None => {
                                                    *base.add(4).cast::<u8>() = (1i32) as u8;
                                                }
                                                V8::NoExtern => {
                                                    *base.add(4).cast::<u8>() = (2i32) as u8;
                                                }
                                                V8::NoFunc => {
                                                    *base.add(4).cast::<u8>() = (3i32) as u8;
                                                }
                                                V8::Eq => {
                                                    *base.add(4).cast::<u8>() = (4i32) as u8;
                                                }
                                                V8::Struct => {
                                                    *base.add(4).cast::<u8>() = (5i32) as u8;
                                                }
                                                V8::Array => {
                                                    *base.add(4).cast::<u8>() = (6i32) as u8;
                                                }
                                                V8::I31 => {
                                                    *base.add(4).cast::<u8>() = (7i32) as u8;
                                                }
                                                V8::Extern => {
                                                    *base.add(4).cast::<u8>() = (8i32) as u8;
                                                }
                                                V8::Func => {
                                                    *base.add(4).cast::<u8>() = (9i32) as u8;
                                                }
                                                V8::Exn => {
                                                    *base.add(4).cast::<u8>() = (10i32) as u8;
                                                }
                                                V8::NoExn => {
                                                    *base.add(4).cast::<u8>() = (11i32) as u8;
                                                }
                                                V8::Cont => {
                                                    *base.add(4).cast::<u8>() = (12i32) as u8;
                                                }
                                                V8::NoCont => {
                                                    *base.add(4).cast::<u8>() = (13i32) as u8;
                                                }
                                                V8::Indexed(e) => {
                                                    *base.add(4).cast::<u8>() = (14i32) as u8;
                                                    *base.add(8).cast::<i32>() = _rt::as_i32(e);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            *base.add(24).cast::<usize>() = len10;
                            *base.add(20).cast::<*mut u8>() = result10;
                        }
                    }
                    *ptr1.add(4).cast::<usize>() = len11;
                    *ptr1.add(0).cast::<*mut u8>() = result11;
                    let vec16 = tables2;
                    let len16 = vec16.len();
                    let layout16 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec16.len() * 48,
                        8,
                    );
                    let result16 = if layout16.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout16).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout16);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec16.into_iter().enumerate() {
                        let base = result16.add(i * 48);
                        {
                            let super::super::super::super::nornor::wasm_analyzer::core_export::Table {
                                field: field12,
                                index: index12,
                                ty: ty12,
                                minimum: minimum12,
                                maximum: maximum12,
                            } = e;
                            let vec13 = (field12.into_bytes()).into_boxed_slice();
                            let ptr13 = vec13.as_ptr().cast::<u8>();
                            let len13 = vec13.len();
                            ::core::mem::forget(vec13);
                            *base.add(4).cast::<usize>() = len13;
                            *base.add(0).cast::<*mut u8>() = ptr13.cast_mut();
                            *base.add(8).cast::<i32>() = _rt::as_i32(index12);
                            use super::super::super::super::nornor::wasm_analyzer::types::WasmType as V15;
                            match ty12 {
                                V15::I32 => {
                                    *base.add(12).cast::<u8>() = (0i32) as u8;
                                }
                                V15::I64 => {
                                    *base.add(12).cast::<u8>() = (1i32) as u8;
                                }
                                V15::F32 => {
                                    *base.add(12).cast::<u8>() = (2i32) as u8;
                                }
                                V15::F64 => {
                                    *base.add(12).cast::<u8>() = (3i32) as u8;
                                }
                                V15::V128 => {
                                    *base.add(12).cast::<u8>() = (4i32) as u8;
                                }
                                V15::RefType(e) => {
                                    *base.add(12).cast::<u8>() = (5i32) as u8;
                                    use super::super::super::super::nornor::wasm_analyzer::types::RefType as V14;
                                    match e {
                                        V14::Any => {
                                            *base.add(16).cast::<u8>() = (0i32) as u8;
                                        }
                                        V14::None => {
                                            *base.add(16).cast::<u8>() = (1i32) as u8;
                                        }
                                        V14::NoExtern => {
                                            *base.add(16).cast::<u8>() = (2i32) as u8;
                                        }
                                        V14::NoFunc => {
                                            *base.add(16).cast::<u8>() = (3i32) as u8;
                                        }
                                        V14::Eq => {
                                            *base.add(16).cast::<u8>() = (4i32) as u8;
                                        }
                                        V14::Struct => {
                                            *base.add(16).cast::<u8>() = (5i32) as u8;
                                        }
                                        V14::Array => {
                                            *base.add(16).cast::<u8>() = (6i32) as u8;
                                        }
                                        V14::I31 => {
                                            *base.add(16).cast::<u8>() = (7i32) as u8;
                                        }
                                        V14::Extern => {
                                            *base.add(16).cast::<u8>() = (8i32) as u8;
                                        }
                                        V14::Func => {
                                            *base.add(16).cast::<u8>() = (9i32) as u8;
                                        }
                                        V14::Exn => {
                                            *base.add(16).cast::<u8>() = (10i32) as u8;
                                        }
                                        V14::NoExn => {
                                            *base.add(16).cast::<u8>() = (11i32) as u8;
                                        }
                                        V14::Cont => {
                                            *base.add(16).cast::<u8>() = (12i32) as u8;
                                        }
                                        V14::NoCont => {
                                            *base.add(16).cast::<u8>() = (13i32) as u8;
                                        }
                                        V14::Indexed(e) => {
                                            *base.add(16).cast::<u8>() = (14i32) as u8;
                                            *base.add(20).cast::<i32>() = _rt::as_i32(e);
                                        }
                                    }
                                }
                            }
                            *base.add(24).cast::<i64>() = _rt::as_i64(minimum12);
                            match maximum12 {
                                Some(e) => {
                                    *base.add(32).cast::<u8>() = (1i32) as u8;
                                    *base.add(40).cast::<i64>() = _rt::as_i64(e);
                                }
                                None => {
                                    *base.add(32).cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                    }
                    *ptr1.add(12).cast::<usize>() = len16;
                    *ptr1.add(8).cast::<*mut u8>() = result16;
                    let vec21 = memories2;
                    let len21 = vec21.len();
                    let layout21 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec21.len() * 64,
                        8,
                    );
                    let result21 = if layout21.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout21).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout21);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec21.into_iter().enumerate() {
                        let base = result21.add(i * 64);
                        {
                            let super::super::super::super::nornor::wasm_analyzer::core_export::Memory {
                                field: field17,
                                index: index17,
                                minimum_pages: minimum_pages17,
                                maximum_pages: maximum_pages17,
                                human_minimum_size: human_minimum_size17,
                                human_maximum_size: human_maximum_size17,
                                shared: shared17,
                                memory64: memory6417,
                            } = e;
                            let vec18 = (field17.into_bytes()).into_boxed_slice();
                            let ptr18 = vec18.as_ptr().cast::<u8>();
                            let len18 = vec18.len();
                            ::core::mem::forget(vec18);
                            *base.add(4).cast::<usize>() = len18;
                            *base.add(0).cast::<*mut u8>() = ptr18.cast_mut();
                            *base.add(8).cast::<i32>() = _rt::as_i32(index17);
                            *base.add(16).cast::<i64>() = _rt::as_i64(minimum_pages17);
                            match maximum_pages17 {
                                Some(e) => {
                                    *base.add(24).cast::<u8>() = (1i32) as u8;
                                    *base.add(32).cast::<i64>() = _rt::as_i64(e);
                                }
                                None => {
                                    *base.add(24).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec19 = (human_minimum_size17.into_bytes())
                                .into_boxed_slice();
                            let ptr19 = vec19.as_ptr().cast::<u8>();
                            let len19 = vec19.len();
                            ::core::mem::forget(vec19);
                            *base.add(44).cast::<usize>() = len19;
                            *base.add(40).cast::<*mut u8>() = ptr19.cast_mut();
                            match human_maximum_size17 {
                                Some(e) => {
                                    *base.add(48).cast::<u8>() = (1i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *base.add(56).cast::<usize>() = len20;
                                    *base.add(52).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                None => {
                                    *base.add(48).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            *base.add(60).cast::<u8>() = (match shared17 {
                                true => 1,
                                false => 0,
                            }) as u8;
                            *base.add(61).cast::<u8>() = (match memory6417 {
                                true => 1,
                                false => 0,
                            }) as u8;
                        }
                    }
                    *ptr1.add(20).cast::<usize>() = len21;
                    *ptr1.add(16).cast::<*mut u8>() = result21;
                    let vec26 = globals2;
                    let len26 = vec26.len();
                    let layout26 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec26.len() * 28,
                        4,
                    );
                    let result26 = if layout26.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout26).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout26);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec26.into_iter().enumerate() {
                        let base = result26.add(i * 28);
                        {
                            let super::super::super::super::nornor::wasm_analyzer::core_export::Global {
                                field: field22,
                                index: index22,
                                ty: ty22,
                                mutable: mutable22,
                            } = e;
                            let vec23 = (field22.into_bytes()).into_boxed_slice();
                            let ptr23 = vec23.as_ptr().cast::<u8>();
                            let len23 = vec23.len();
                            ::core::mem::forget(vec23);
                            *base.add(4).cast::<usize>() = len23;
                            *base.add(0).cast::<*mut u8>() = ptr23.cast_mut();
                            *base.add(8).cast::<i32>() = _rt::as_i32(index22);
                            use super::super::super::super::nornor::wasm_analyzer::types::WasmType as V25;
                            match ty22 {
                                V25::I32 => {
                                    *base.add(12).cast::<u8>() = (0i32) as u8;
                                }
                                V25::I64 => {
                                    *base.add(12).cast::<u8>() = (1i32) as u8;
                                }
                                V25::F32 => {
                                    *base.add(12).cast::<u8>() = (2i32) as u8;
                                }
                                V25::F64 => {
                                    *base.add(12).cast::<u8>() = (3i32) as u8;
                                }
                                V25::V128 => {
                                    *base.add(12).cast::<u8>() = (4i32) as u8;
                                }
                                V25::RefType(e) => {
                                    *base.add(12).cast::<u8>() = (5i32) as u8;
                                    use super::super::super::super::nornor::wasm_analyzer::types::RefType as V24;
                                    match e {
                                        V24::Any => {
                                            *base.add(16).cast::<u8>() = (0i32) as u8;
                                        }
                                        V24::None => {
                                            *base.add(16).cast::<u8>() = (1i32) as u8;
                                        }
                                        V24::NoExtern => {
                                            *base.add(16).cast::<u8>() = (2i32) as u8;
                                        }
                                        V24::NoFunc => {
                                            *base.add(16).cast::<u8>() = (3i32) as u8;
                                        }
                                        V24::Eq => {
                                            *base.add(16).cast::<u8>() = (4i32) as u8;
                                        }
                                        V24::Struct => {
                                            *base.add(16).cast::<u8>() = (5i32) as u8;
                                        }
                                        V24::Array => {
                                            *base.add(16).cast::<u8>() = (6i32) as u8;
                                        }
                                        V24::I31 => {
                                            *base.add(16).cast::<u8>() = (7i32) as u8;
                                        }
                                        V24::Extern => {
                                            *base.add(16).cast::<u8>() = (8i32) as u8;
                                        }
                                        V24::Func => {
                                            *base.add(16).cast::<u8>() = (9i32) as u8;
                                        }
                                        V24::Exn => {
                                            *base.add(16).cast::<u8>() = (10i32) as u8;
                                        }
                                        V24::NoExn => {
                                            *base.add(16).cast::<u8>() = (11i32) as u8;
                                        }
                                        V24::Cont => {
                                            *base.add(16).cast::<u8>() = (12i32) as u8;
                                        }
                                        V24::NoCont => {
                                            *base.add(16).cast::<u8>() = (13i32) as u8;
                                        }
                                        V24::Indexed(e) => {
                                            *base.add(16).cast::<u8>() = (14i32) as u8;
                                            *base.add(20).cast::<i32>() = _rt::as_i32(e);
                                        }
                                    }
                                }
                            }
                            *base.add(24).cast::<u8>() = (match mutable22 {
                                true => 1,
                                false => 0,
                            }) as u8;
                        }
                    }
                    *ptr1.add(28).cast::<usize>() = len26;
                    *ptr1.add(24).cast::<*mut u8>() = result26;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_component_get_core_exports<
                    T: GuestComponent,
                >(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let base10 = l0;
                    let len10 = l1;
                    for i in 0..len10 {
                        let base = base10.add(i * 28);
                        {
                            let l2 = *base.add(0).cast::<*mut u8>();
                            let l3 = *base.add(4).cast::<usize>();
                            _rt::cabi_dealloc(l2, l3, 1);
                            let l4 = *base.add(12).cast::<*mut u8>();
                            let l5 = *base.add(16).cast::<usize>();
                            let base6 = l4;
                            let len6 = l5;
                            _rt::cabi_dealloc(base6, len6 * 12, 4);
                            let l7 = *base.add(20).cast::<*mut u8>();
                            let l8 = *base.add(24).cast::<usize>();
                            let base9 = l7;
                            let len9 = l8;
                            _rt::cabi_dealloc(base9, len9 * 12, 4);
                        }
                    }
                    _rt::cabi_dealloc(base10, len10 * 28, 4);
                    let l11 = *arg0.add(8).cast::<*mut u8>();
                    let l12 = *arg0.add(12).cast::<usize>();
                    let base15 = l11;
                    let len15 = l12;
                    for i in 0..len15 {
                        let base = base15.add(i * 48);
                        {
                            let l13 = *base.add(0).cast::<*mut u8>();
                            let l14 = *base.add(4).cast::<usize>();
                            _rt::cabi_dealloc(l13, l14, 1);
                        }
                    }
                    _rt::cabi_dealloc(base15, len15 * 48, 8);
                    let l16 = *arg0.add(16).cast::<*mut u8>();
                    let l17 = *arg0.add(20).cast::<usize>();
                    let base25 = l16;
                    let len25 = l17;
                    for i in 0..len25 {
                        let base = base25.add(i * 64);
                        {
                            let l18 = *base.add(0).cast::<*mut u8>();
                            let l19 = *base.add(4).cast::<usize>();
                            _rt::cabi_dealloc(l18, l19, 1);
                            let l20 = *base.add(40).cast::<*mut u8>();
                            let l21 = *base.add(44).cast::<usize>();
                            _rt::cabi_dealloc(l20, l21, 1);
                            let l22 = i32::from(*base.add(48).cast::<u8>());
                            match l22 {
                                0 => {}
                                _ => {
                                    let l23 = *base.add(52).cast::<*mut u8>();
                                    let l24 = *base.add(56).cast::<usize>();
                                    _rt::cabi_dealloc(l23, l24, 1);
                                }
                            }
                        }
                    }
                    _rt::cabi_dealloc(base25, len25 * 64, 8);
                    let l26 = *arg0.add(24).cast::<*mut u8>();
                    let l27 = *arg0.add(28).cast::<usize>();
                    let base30 = l26;
                    let len30 = l27;
                    for i in 0..len30 {
                        let base = base30.add(i * 28);
                        {
                            let l28 = *base.add(0).cast::<*mut u8>();
                            let l29 = *base.add(4).cast::<usize>();
                            _rt::cabi_dealloc(l28, l29, 1);
                        }
                    }
                    _rt::cabi_dealloc(base30, len30 * 28, 4);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_component_get_custom_sections_cabi<
                    T: GuestComponent,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_custom_sections(
                        ComponentBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec5 = result0;
                    let len5 = vec5.len();
                    let layout5 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec5.len() * 24,
                        8,
                    );
                    let result5 = if layout5.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout5);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec5.into_iter().enumerate() {
                        let base = result5.add(i * 24);
                        {
                            let super::super::super::super::nornor::wasm_analyzer::types::CustomSection {
                                name: name2,
                                human_size: human_size2,
                                size: size2,
                            } = e;
                            let vec3 = (name2.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *base.add(4).cast::<usize>() = len3;
                            *base.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                            let vec4 = (human_size2.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *base.add(12).cast::<usize>() = len4;
                            *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                            *base.add(16).cast::<i64>() = _rt::as_i64(size2);
                        }
                    }
                    *ptr1.add(4).cast::<usize>() = len5;
                    *ptr1.add(0).cast::<*mut u8>() = result5;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_component_get_custom_sections<
                    T: GuestComponent,
                >(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let base6 = l0;
                    let len6 = l1;
                    for i in 0..len6 {
                        let base = base6.add(i * 24);
                        {
                            let l2 = *base.add(0).cast::<*mut u8>();
                            let l3 = *base.add(4).cast::<usize>();
                            _rt::cabi_dealloc(l2, l3, 1);
                            let l4 = *base.add(8).cast::<*mut u8>();
                            let l5 = *base.add(12).cast::<usize>();
                            _rt::cabi_dealloc(l4, l5, 1);
                        }
                    }
                    _rt::cabi_dealloc(base6, len6 * 24, 8);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_component_get_child_components_cabi<
                    T: GuestComponent,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_child_components(
                        ComponentBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec2 = result0;
                    let len2 = vec2.len();
                    let layout2 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec2.len() * 4,
                        4,
                    );
                    let result2 = if layout2.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout2).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout2);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec2.into_iter().enumerate() {
                        let base = result2.add(i * 4);
                        {
                            *base.add(0).cast::<i32>() = (e).take_handle() as i32;
                        }
                    }
                    *ptr1.add(4).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = result2;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_component_get_child_components<
                    T: GuestComponent,
                >(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let base2 = l0;
                    let len2 = l1;
                    _rt::cabi_dealloc(base2, len2 * 4, 4);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_component_get_wit_cabi<T: GuestComponent>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_wit(
                        ComponentBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Some(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let vec2 = (e.into_bytes()).into_boxed_slice();
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            ::core::mem::forget(vec2);
                            *ptr1.add(8).cast::<usize>() = len2;
                            *ptr1.add(4).cast::<*mut u8>() = ptr2.cast_mut();
                        }
                        None => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_component_get_wit<T: GuestComponent>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = *arg0.add(4).cast::<*mut u8>();
                            let l2 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_component_get_wat_cabi<T: GuestComponent>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_wat(
                        ComponentBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(4).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_component_get_wat<T: GuestComponent>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_constructor_wasm_reader_cabi<T: GuestWasmReader>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = WasmReader::new(
                        T::new(_rt::Vec::from_raw_parts(arg0.cast(), len0, len0)),
                    );
                    (result1).take_handle() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_wasm_reader_get_root_component_cabi<
                    T: GuestWasmReader,
                >(arg0: *mut u8) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_root_component(
                        WasmReaderBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    (result0).take_handle() as i32
                }
                pub trait Guest {
                    type Component: GuestComponent;
                    type WasmReader: GuestWasmReader;
                }
                pub trait GuestComponent: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nornor:wasm-analyzer/reader@0.1.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-new]component"]
                                fn new(_: *mut u8) -> u32;
                            }
                            new(val)
                        }
                    }
                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nornor:wasm-analyzer/reader@0.1.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-rep]component"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }
                    fn new(bytes: _rt::Vec<u8>) -> Self;
                    fn get_type(&self) -> WasmModuleType;
                    fn get_module_information(&self) -> MetadataInformation;
                    fn get_core_imports(&self) -> CoreImports;
                    fn get_core_exports(&self) -> CoreExports;
                    fn get_custom_sections(&self) -> _rt::Vec<CustomSection>;
                    fn get_child_components(&self) -> _rt::Vec<Component>;
                    fn get_wit(&self) -> Option<_rt::String>;
                    fn get_wat(&self) -> _rt::String;
                }
                pub trait GuestWasmReader: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nornor:wasm-analyzer/reader@0.1.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-new]wasm-reader"]
                                fn new(_: *mut u8) -> u32;
                            }
                            new(val)
                        }
                    }
                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]nornor:wasm-analyzer/reader@0.1.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-rep]wasm-reader"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }
                    fn new(bytes: _rt::Vec<u8>) -> Self;
                    fn get_root_component(&self) -> Component;
                }
                #[doc(hidden)]
                macro_rules! __export_nornor_wasm_analyzer_reader_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[export_name =
                        "nornor:wasm-analyzer/reader@0.1.0#[constructor]component"]
                        unsafe extern "C" fn export_constructor_component(arg0 : * mut
                        u8, arg1 : usize,) -> i32 { $($path_to_types)*::
                        _export_constructor_component_cabi::<<$ty as $($path_to_types)*::
                        Guest >::Component > (arg0, arg1) } #[export_name =
                        "nornor:wasm-analyzer/reader@0.1.0#[method]component.get-type"]
                        unsafe extern "C" fn export_method_component_get_type(arg0 : *
                        mut u8,) -> i32 { $($path_to_types)*::
                        _export_method_component_get_type_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Component > (arg0) } #[export_name
                        =
                        "nornor:wasm-analyzer/reader@0.1.0#[method]component.get-module-information"]
                        unsafe extern "C" fn
                        export_method_component_get_module_information(arg0 : * mut u8,)
                        -> * mut u8 { $($path_to_types)*::
                        _export_method_component_get_module_information_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Component > (arg0) } #[export_name
                        =
                        "cabi_post_nornor:wasm-analyzer/reader@0.1.0#[method]component.get-module-information"]
                        unsafe extern "C" fn
                        _post_return_method_component_get_module_information(arg0 : * mut
                        u8,) { $($path_to_types)*::
                        __post_return_method_component_get_module_information::<<$ty as
                        $($path_to_types)*:: Guest >::Component > (arg0) } #[export_name
                        =
                        "nornor:wasm-analyzer/reader@0.1.0#[method]component.get-core-imports"]
                        unsafe extern "C" fn
                        export_method_component_get_core_imports(arg0 : * mut u8,) -> *
                        mut u8 { $($path_to_types)*::
                        _export_method_component_get_core_imports_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Component > (arg0) } #[export_name
                        =
                        "cabi_post_nornor:wasm-analyzer/reader@0.1.0#[method]component.get-core-imports"]
                        unsafe extern "C" fn
                        _post_return_method_component_get_core_imports(arg0 : * mut u8,)
                        { $($path_to_types)*::
                        __post_return_method_component_get_core_imports::<<$ty as
                        $($path_to_types)*:: Guest >::Component > (arg0) } #[export_name
                        =
                        "nornor:wasm-analyzer/reader@0.1.0#[method]component.get-core-exports"]
                        unsafe extern "C" fn
                        export_method_component_get_core_exports(arg0 : * mut u8,) -> *
                        mut u8 { $($path_to_types)*::
                        _export_method_component_get_core_exports_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Component > (arg0) } #[export_name
                        =
                        "cabi_post_nornor:wasm-analyzer/reader@0.1.0#[method]component.get-core-exports"]
                        unsafe extern "C" fn
                        _post_return_method_component_get_core_exports(arg0 : * mut u8,)
                        { $($path_to_types)*::
                        __post_return_method_component_get_core_exports::<<$ty as
                        $($path_to_types)*:: Guest >::Component > (arg0) } #[export_name
                        =
                        "nornor:wasm-analyzer/reader@0.1.0#[method]component.get-custom-sections"]
                        unsafe extern "C" fn
                        export_method_component_get_custom_sections(arg0 : * mut u8,) ->
                        * mut u8 { $($path_to_types)*::
                        _export_method_component_get_custom_sections_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Component > (arg0) } #[export_name
                        =
                        "cabi_post_nornor:wasm-analyzer/reader@0.1.0#[method]component.get-custom-sections"]
                        unsafe extern "C" fn
                        _post_return_method_component_get_custom_sections(arg0 : * mut
                        u8,) { $($path_to_types)*::
                        __post_return_method_component_get_custom_sections::<<$ty as
                        $($path_to_types)*:: Guest >::Component > (arg0) } #[export_name
                        =
                        "nornor:wasm-analyzer/reader@0.1.0#[method]component.get-child-components"]
                        unsafe extern "C" fn
                        export_method_component_get_child_components(arg0 : * mut u8,) ->
                        * mut u8 { $($path_to_types)*::
                        _export_method_component_get_child_components_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Component > (arg0) } #[export_name
                        =
                        "cabi_post_nornor:wasm-analyzer/reader@0.1.0#[method]component.get-child-components"]
                        unsafe extern "C" fn
                        _post_return_method_component_get_child_components(arg0 : * mut
                        u8,) { $($path_to_types)*::
                        __post_return_method_component_get_child_components::<<$ty as
                        $($path_to_types)*:: Guest >::Component > (arg0) } #[export_name
                        = "nornor:wasm-analyzer/reader@0.1.0#[method]component.get-wit"]
                        unsafe extern "C" fn export_method_component_get_wit(arg0 : * mut
                        u8,) -> * mut u8 { $($path_to_types)*::
                        _export_method_component_get_wit_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Component > (arg0) } #[export_name
                        =
                        "cabi_post_nornor:wasm-analyzer/reader@0.1.0#[method]component.get-wit"]
                        unsafe extern "C" fn _post_return_method_component_get_wit(arg0 :
                        * mut u8,) { $($path_to_types)*::
                        __post_return_method_component_get_wit::<<$ty as
                        $($path_to_types)*:: Guest >::Component > (arg0) } #[export_name
                        = "nornor:wasm-analyzer/reader@0.1.0#[method]component.get-wat"]
                        unsafe extern "C" fn export_method_component_get_wat(arg0 : * mut
                        u8,) -> * mut u8 { $($path_to_types)*::
                        _export_method_component_get_wat_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Component > (arg0) } #[export_name
                        =
                        "cabi_post_nornor:wasm-analyzer/reader@0.1.0#[method]component.get-wat"]
                        unsafe extern "C" fn _post_return_method_component_get_wat(arg0 :
                        * mut u8,) { $($path_to_types)*::
                        __post_return_method_component_get_wat::<<$ty as
                        $($path_to_types)*:: Guest >::Component > (arg0) } #[export_name
                        = "nornor:wasm-analyzer/reader@0.1.0#[constructor]wasm-reader"]
                        unsafe extern "C" fn export_constructor_wasm_reader(arg0 : * mut
                        u8, arg1 : usize,) -> i32 { $($path_to_types)*::
                        _export_constructor_wasm_reader_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::WasmReader > (arg0, arg1) }
                        #[export_name =
                        "nornor:wasm-analyzer/reader@0.1.0#[method]wasm-reader.get-root-component"]
                        unsafe extern "C" fn
                        export_method_wasm_reader_get_root_component(arg0 : * mut u8,) ->
                        i32 { $($path_to_types)*::
                        _export_method_wasm_reader_get_root_component_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::WasmReader > (arg0) } const _ : ()
                        = { #[doc(hidden)] #[export_name =
                        "nornor:wasm-analyzer/reader@0.1.0#[dtor]component"]
                        #[allow(non_snake_case)] unsafe extern "C" fn dtor(rep : * mut
                        u8) { $($path_to_types)*:: Component::dtor::< <$ty as
                        $($path_to_types)*:: Guest >::Component > (rep) } }; const _ : ()
                        = { #[doc(hidden)] #[export_name =
                        "nornor:wasm-analyzer/reader@0.1.0#[dtor]wasm-reader"]
                        #[allow(non_snake_case)] unsafe extern "C" fn dtor(rep : * mut
                        u8) { $($path_to_types)*:: WasmReader::dtor::< <$ty as
                        $($path_to_types)*:: Guest >::WasmReader > (rep) } }; };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_nornor_wasm_analyzer_reader_0_1_0_cabi;
                #[repr(align(8))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 80]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 80],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    use core::fmt;
    use core::marker;
    use core::sync::atomic::{AtomicU32, Ordering::Relaxed};
    /// A type which represents a component model resource, either imported or
    /// exported into this component.
    ///
    /// This is a low-level wrapper which handles the lifetime of the resource
    /// (namely this has a destructor). The `T` provided defines the component model
    /// intrinsics that this wrapper uses.
    ///
    /// One of the chief purposes of this type is to provide `Deref` implementations
    /// to access the underlying data when it is owned.
    ///
    /// This type is primarily used in generated code for exported and imported
    /// resources.
    #[repr(transparent)]
    pub struct Resource<T: WasmResource> {
        handle: AtomicU32,
        _marker: marker::PhantomData<T>,
    }
    /// A trait which all wasm resources implement, namely providing the ability to
    /// drop a resource.
    ///
    /// This generally is implemented by generated code, not user-facing code.
    #[allow(clippy::missing_safety_doc)]
    pub unsafe trait WasmResource {
        /// Invokes the `[resource-drop]...` intrinsic.
        unsafe fn drop(handle: u32);
    }
    impl<T: WasmResource> Resource<T> {
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
            debug_assert!(handle != u32::MAX);
            Self {
                handle: AtomicU32::new(handle),
                _marker: marker::PhantomData,
            }
        }
        /// Takes ownership of the handle owned by `resource`.
        ///
        /// Note that this ideally would be `into_handle` taking `Resource<T>` by
        /// ownership. The code generator does not enable that in all situations,
        /// unfortunately, so this is provided instead.
        ///
        /// Also note that `take_handle` is in theory only ever called on values
        /// owned by a generated function. For example a generated function might
        /// take `Resource<T>` as an argument but then call `take_handle` on a
        /// reference to that argument. In that sense the dynamic nature of
        /// `take_handle` should only be exposed internally to generated code, not
        /// to user code.
        #[doc(hidden)]
        pub fn take_handle(resource: &Resource<T>) -> u32 {
            resource.handle.swap(u32::MAX, Relaxed)
        }
        #[doc(hidden)]
        pub fn handle(resource: &Resource<T>) -> u32 {
            resource.handle.load(Relaxed)
        }
    }
    impl<T: WasmResource> fmt::Debug for Resource<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Resource").field("handle", &self.handle).finish()
        }
    }
    impl<T: WasmResource> Drop for Resource<T> {
        fn drop(&mut self) {
            unsafe {
                match self.handle.load(Relaxed) {
                    u32::MAX => {}
                    other => T::drop(other),
                }
            }
        }
    }
    pub use alloc_crate::boxed::Box;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub use alloc_crate::alloc;
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_wasm_analyzer_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::nornor::wasm_analyzer::reader::__export_nornor_wasm_analyzer_reader_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::nornor::wasm_analyzer::reader);
    };
}
#[doc(inline)]
pub(crate) use __export_wasm_analyzer_impl as export;
#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.36.0:nornor:wasm-analyzer@0.1.0:wasm-analyzer:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 2454] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x92\x12\x01A\x02\x01\
A\x0e\x01B\x11\x01r\x03\x04names\x0ahuman-sizes\x04sizew\x04\0\x0ecustom-section\
\x03\0\0\x01ks\x01r\x02\x05fields\x07version\x02\x04\0\x08metadata\x03\0\x03\x01\
r\x02\x05fields\x08metadata\x04\x04\0\x0cunkown-field\x03\0\x05\x01m\x03\x04core\
\x09component\x09interface\x04\0\x10wasm-module-type\x03\0\x07\x01p\x04\x01p\x06\
\x01r\x0b\x04names\x04sizew\x0ahuman-sizes\x06sha256s\x09languages\x09\x05tools\x09\
\x04sdks\x09\x0funknow-metadata\x0a\x13num-custom-sectionsy\x10num-core-importsy\
\x0fnum-core-exporty\x04\0\x14metadata-information\x03\0\x0b\x01q\x0f\x03any\0\0\
\x04none\0\0\x09no-extern\0\0\x07no-func\0\0\x02eq\0\0\x06struct\0\0\x05array\0\0\
\x03i31\0\0\x06extern\0\0\x04func\0\0\x03exn\0\0\x06no-exn\0\0\x04cont\0\0\x07no\
-cont\0\0\x07indexed\x01y\0\x04\0\x08ref-type\x03\0\x0d\x01q\x06\x03i32\0\0\x03i\
64\0\0\x03f32\0\0\x03f64\0\0\x04v128\0\0\x08ref-type\x01\x0e\0\x04\0\x09wasm-typ\
e\x03\0\x0f\x03\0\x20nornor:wasm-analyzer/types@0.1.0\x05\0\x02\x03\0\0\x09wasm-\
type\x01B\x13\x02\x03\x02\x01\x01\x04\0\x09wasm-type\x03\0\0\x01p\x01\x01r\x05\x06\
modules\x05fields\x05indexy\x06params\x02\x07results\x02\x04\0\x08function\x03\0\
\x03\x01kw\x01r\x06\x06modules\x05fields\x05indexy\x02ty\x01\x07minimumw\x07maxi\
mum\x05\x04\0\x05table\x03\0\x06\x01ks\x01r\x09\x06modules\x05fields\x05indexy\x0d\
minimum-pagesw\x0dmaximum-pages\x05\x12human-minimum-sizes\x12human-maximum-size\
\x08\x06shared\x7f\x08memory64\x7f\x04\0\x06memory\x03\0\x09\x01r\x05\x06modules\
\x05fields\x05indexy\x02ty\x01\x07mutable\x7f\x04\0\x06global\x03\0\x0b\x01p\x04\
\x01p\x07\x01p\x0a\x01p\x0c\x01r\x04\x09functions\x0d\x06tables\x0e\x08memories\x0f\
\x07globals\x10\x04\0\x0ccore-imports\x03\0\x11\x03\0&nornor:wasm-analyzer/core-\
import@0.1.0\x05\x02\x01B\x13\x02\x03\x02\x01\x01\x04\0\x09wasm-type\x03\0\0\x01\
p\x01\x01r\x04\x05fields\x05indexy\x06params\x02\x07results\x02\x04\0\x08functio\
n\x03\0\x03\x01kw\x01r\x05\x05fields\x05indexy\x02ty\x01\x07minimumw\x07maximum\x05\
\x04\0\x05table\x03\0\x06\x01ks\x01r\x08\x05fields\x05indexy\x0dminimum-pagesw\x0d\
maximum-pages\x05\x12human-minimum-sizes\x12human-maximum-size\x08\x06shared\x7f\
\x08memory64\x7f\x04\0\x06memory\x03\0\x09\x01r\x04\x05fields\x05indexy\x02ty\x01\
\x07mutable\x7f\x04\0\x06global\x03\0\x0b\x01p\x04\x01p\x07\x01p\x0a\x01p\x0c\x01\
r\x04\x09functions\x0d\x06tables\x0e\x08memories\x0f\x07globals\x10\x04\0\x0ccor\
e-exports\x03\0\x11\x03\0&nornor:wasm-analyzer/core-export@0.1.0\x05\x03\x02\x03\
\0\x01\x0ccore-imports\x02\x03\0\x02\x0ccore-exports\x02\x03\0\0\x10wasm-module-\
type\x02\x03\0\0\x14metadata-information\x02\x03\0\0\x0ecustom-section\x01B*\x02\
\x03\x02\x01\x04\x04\0\x0ccore-imports\x03\0\0\x02\x03\x02\x01\x05\x04\0\x0ccore\
-exports\x03\0\x02\x02\x03\x02\x01\x06\x04\0\x10wasm-module-type\x03\0\x04\x02\x03\
\x02\x01\x07\x04\0\x14metadata-information\x03\0\x06\x02\x03\x02\x01\x08\x04\0\x0e\
custom-section\x03\0\x08\x04\0\x09component\x03\x01\x04\0\x0bwasm-reader\x03\x01\
\x01p}\x01i\x0a\x01@\x01\x05bytes\x0c\0\x0d\x04\0\x16[constructor]component\x01\x0e\
\x01h\x0a\x01@\x01\x04self\x0f\0\x05\x04\0\x1a[method]component.get-type\x01\x10\
\x01@\x01\x04self\x0f\0\x07\x04\0([method]component.get-module-information\x01\x11\
\x01@\x01\x04self\x0f\0\x01\x04\0\"[method]component.get-core-imports\x01\x12\x01\
@\x01\x04self\x0f\0\x03\x04\0\"[method]component.get-core-exports\x01\x13\x01p\x09\
\x01@\x01\x04self\x0f\0\x14\x04\0%[method]component.get-custom-sections\x01\x15\x01\
p\x0d\x01@\x01\x04self\x0f\0\x16\x04\0&[method]component.get-child-components\x01\
\x17\x01ks\x01@\x01\x04self\x0f\0\x18\x04\0\x19[method]component.get-wit\x01\x19\
\x01@\x01\x04self\x0f\0s\x04\0\x19[method]component.get-wat\x01\x1a\x01i\x0b\x01\
@\x01\x05bytes\x0c\0\x1b\x04\0\x18[constructor]wasm-reader\x01\x1c\x01h\x0b\x01@\
\x01\x04self\x1d\0\x0d\x04\0&[method]wasm-reader.get-root-component\x01\x1e\x04\0\
!nornor:wasm-analyzer/reader@0.1.0\x05\x09\x04\0(nornor:wasm-analyzer/wasm-analy\
zer@0.1.0\x04\0\x0b\x13\x01\0\x0dwasm-analyzer\x03\0\0\0G\x09producers\x01\x0cpr\
ocessed-by\x02\x0dwit-component\x070.220.0\x10wit-bindgen-rust\x060.36.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
